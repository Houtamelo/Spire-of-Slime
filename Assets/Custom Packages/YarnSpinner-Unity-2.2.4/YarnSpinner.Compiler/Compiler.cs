// Uncomment to ensure that all expressions have a known type at compile time
// #define VALIDATE_ALL_EXPRESSIONS

using System.Reflection;
// ReSharper disable PossibleUnintendedReferenceComparison

namespace Yarn.Compiler
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text.RegularExpressions;
    using Antlr4.Runtime;
    using Antlr4.Runtime.Tree;
    using static Yarn.Instruction.Types;

    public class StringTableManager
    {
        public Dictionary<string, StringInfo> StringTable = new Dictionary<string, StringInfo>();

        public bool ContainsImplicitStringTags
        {
            get
            {
                foreach (KeyValuePair<string, StringInfo> item in this.StringTable)
                {
                    if (item.Value.isImplicitTag)
                    {
                        return true;
                    }
                }
                return false;
            }
        }

        /// <summary>
        /// Registers a new string in the string table.
        /// </summary>
        /// <param name="text">The text of the string to register.</param>
        /// <param name="nodeName">The name of the node that this string
        /// was found in.</param>
        /// <param name="lineID">The line ID to use for this entry in the
        /// string table.</param>
        /// <param name="lineNumber">The line number that this string was
        /// found in.</param>
        /// <param name="tags">The tags to associate with this string in
        /// the string table.</param>
        /// <returns>The string ID for the newly registered
        /// string.</returns>
        /// <remarks>If <paramref name="lineID"/> is <see
        /// langword="null"/>, a line ID will be generated from <paramref
        /// name="fileName"/>, <paramref name="nodeName"/>, and the number
        /// of elements in <see cref="StringTable"/>.</remarks>
        public string RegisterString(string text, string fileName, string nodeName, string lineID, int lineNumber, string[] tags)
        {
            string lineIDUsed;

            bool isImplicit;

            if (lineID == null)
            {
                lineIDUsed = $"line:{fileName}-{nodeName}-{this.StringTable.Count}";

                isImplicit = true;
            }
            else
            {
                lineIDUsed = lineID;

                isImplicit = false;
            }

            StringInfo theString = new StringInfo(text, fileName, nodeName, lineNumber, isImplicit, tags);

            // Finally, add this to the string table, and return the line
            // ID.
            this.StringTable.Add(lineIDUsed, theString);

            return lineIDUsed;
        }

        public void Add(IDictionary<string, StringInfo> otherStringTable)
        {
            foreach (KeyValuePair<string, StringInfo> entry in otherStringTable)
            {
                this.StringTable.Add(entry.Key, entry.Value);
            }
        }

        /// <summary>
        /// Checks to see if this string table already contains a line with
        /// the line ID <paramref name="lineID"/>.
        /// </summary>
        /// <param name="lineID">The line ID to check for.</param>
        /// <returns><see langword="true"/> if the string table already
        /// contains a line with this ID, <see langword="false"/>
        /// otherwise.</returns>
        public bool ContainsKey(string lineID)
        {
            return this.StringTable.ContainsKey(lineID);
        }
    }

    /// <summary>
    /// Information about a string. Stored inside a string table, which is
    /// produced from the Compiler.
    /// </summary>
    /// <remarks>
    /// You do not create instances of this class yourself. They are
    /// generated by the <see cref="Compiler"/>.
    /// </remarks>
    public struct StringInfo
    {
        /// <summary>
        /// The original text of the string.
        /// </summary>
        public string text;

        /// <summary>
        /// The name of the node that this string was found in.
        /// </summary>
        public string nodeName;

        /// <summary>
        /// The line number at which this string was found in the file.
        /// </summary>
        public int lineNumber;

        /// <summary>
        /// The name of the file this string was found in.
        /// </summary>
        public string fileName;

        /// <summary>
        /// Indicates whether this string's line ID was implicitly
        /// generated.
        /// </summary>
        /// <remarks>
        /// Implicitly generated line IDs are not guaranteed to remain the
        /// same across multiple compilations. To ensure that a line ID
        /// remains the same, you must define it by adding a line tag to the
        /// line.
        /// </remarks>
        public bool isImplicitTag;

        /// <summary>
        /// The metadata (i.e. hashtags) associated with this string.
        /// </summary>
        /// <remarks>
        /// This array will contain any hashtags associated with this
        /// string besides the <c>#line:</c> hashtag.
        /// </remarks>
        public string[] metadata;

        /// <summary>
        /// Initializes a new instance of the <see cref="StringInfo"/>
        /// struct.
        /// </summary>
        /// <param name="text">The text of the string.</param>
        /// <param name="fileName">The file name.</param>
        /// <param name="nodeName">The node name.</param>
        /// <param name="lineNumber">The line number.</param>
        /// <param name="isImplicitTag">If <c>true</c>, this string info is
        /// stored with an implicit line ID.</param>
        /// <param name="metadata">The string's metadata.</param>
        public StringInfo(string text, string fileName, string nodeName, int lineNumber, bool isImplicitTag, string[] metadata)
        {
            this.text = text;
            this.nodeName = nodeName;
            this.lineNumber = lineNumber;
            this.fileName = fileName;
            this.isImplicitTag = isImplicitTag;

            if (metadata != null)
            {
                this.metadata = metadata;
            }
            else
            {
                this.metadata = new string[] { };
            }

        }

        /// <inheritdoc/>
        public override string ToString()
        {
            return $"{this.text} ({this.fileName}:{this.lineNumber})";
        }
    }

    /// <summary>
    /// An object that contains Yarn source code to compile, and instructions on
    /// how to compile it.
    /// </summary>
    /// <remarks>
    /// Instances of this struct are used with <see
    /// cref="Compiler.Compile(CompilationJob)"/> to produce <see
    /// cref="CompilationResult"/> objects.
    /// </remarks>
    public struct CompilationJob
    {

        /// <summary>
        /// Represents the contents of a file to compile.
        /// </summary>
        public struct File
        {
            /// <summary>
            /// The name of the file. 
            /// </summary>
            /// <remarks>
            /// This may be a full path, or just the filename or anything in
            /// between. This is useful for diagnostics, and for attributing
            /// <see cref="Line"/> objects to their original source
            /// files.</remarks>
            public string FileName;

            /// <summary>
            /// The source code of this file.
            /// </summary>
            public string Source;
        }

        /// <summary>
        /// The type of compilation that the compiler will do.
        /// </summary>
        public enum Type
        {
            /// <summary>The compiler will do a full compilation, and
            /// generate a <see cref="Program"/>, function declaration set,
            /// and string table.</summary>
            FullCompilation,

            /// <summary>The compiler will derive only the variable and
            /// function declarations, and file tags, found in the
            /// script.</summary>
            DeclarationsOnly,

            /// <summary>The compiler will generate a string table
            /// only.</summary>
            StringsOnly,
        }

        /// <summary>
        /// The <see cref="File"/> structs that represent the content to
        /// parse..
        /// </summary>
        public IEnumerable<File> Files;

        /// <summary>
        /// The <see cref="Library"/> that contains declarations for
        /// functions.
        /// </summary>
        public Library Library;

        /// <summary>
        /// The type of compilation to perform.
        /// </summary>
        public Type CompilationType;

        /// <summary>
        /// The declarations for variables.
        /// </summary>
        public IEnumerable<Declaration> VariableDeclarations;

        /// <summary>
        /// Creates a new <see cref="CompilationJob"/> using the contents of a
        /// collection of files.
        /// </summary>
        /// <param name="paths">The paths to the files.</param>
        /// <param name="library">The <see cref="Library"/> containing functions
        /// to use for this compilation.</param>
        /// <returns>A new <see cref="CompilationJob"/>.</returns>
        public static CompilationJob CreateFromFiles(IEnumerable<string> paths, Library library = null)
        {
            List<File> fileList = new List<File>();

            // Read every file and add it to the file list
            foreach (string path in paths)
            {
                fileList.Add(new File
                {
                    FileName = path,
                    Source = System.IO.File.ReadAllText(path),
                });
            }

            return new CompilationJob
            {
                Files = fileList.ToArray(),
                Library = library,
            };
        }

        /// <inheritdoc cref="CreateFromFiles(IEnumerable{string}, Library)" path="/summary"/>
        /// <inheritdoc cref="CreateFromFiles(IEnumerable{string}, Library)" path="/param[@name='paths']"/>
        /// <inheritdoc cref="CreateFromFiles(IEnumerable{string}, Library)" path="/returns"/>
        public static CompilationJob CreateFromFiles(params string[] paths)
        {
            return CreateFromFiles((IEnumerable<string>)paths);
        }

        /// <summary>
        /// Creates a new <see cref="CompilationJob"/> using the contents
        /// of a string.
        /// </summary>
        /// <param name="fileName">The name to assign to the compiled
        /// file.</param>
        /// <param name="source">The text to compile.</param>
        /// <param name="library">Library of function definitions to use
        /// during compilation.</param>
        /// <returns>A new <see cref="CompilationJob"/>.</returns>
        public static CompilationJob CreateFromString(string fileName, string source, Library library = null)
        {
            return new CompilationJob
            {
                Files = new List<File>
                {
                    new File {
                        Source = source, FileName = fileName
                    },
                },
                Library = library,
            };
        }
    }

    /// <summary>
    /// The result of a compilation.
    /// </summary>
    /// <remarks>
    /// Instances of this struct are produced as a result of supplying a <see
    /// cref="CompilationJob"/> to <see
    /// cref="Compiler.Compile(CompilationJob)"/>.
    /// </remarks>
    public struct CompilationResult
    {
        /// <summary>
        /// Gets the compiled Yarn program that the <see cref="Compiler"/>
        /// produced.
        /// </summary>
        /// <remarks>
        /// <para>This value will be <see langword="null"/> if there were errors
        /// in the compilation. If this is the case, <see cref="Diagnostics"/>
        /// will contain information describing the errors.</para>
        /// <para>
        /// It will also be <see langword="null"/> if the <see
        /// cref="CompilationJob"/> object's <see
        /// cref="CompilationJob.CompilationType"/> value was not <see
        /// cref="CompilationJob.Type.FullCompilation"/>.
        /// </para>
        /// </remarks>
        public Program Program { get; set; }

        /// <summary>
        /// Gets a dictionary mapping line IDs to StringInfo objects.
        /// </summary>
        /// <remarks>
        /// The string table contains the extracted line text found in the
        /// provided source code. The keys of this dictionary are the line IDs
        /// for each line - either through explicit line tags indicated through
        /// the <c>#line:</c> tag, or implicitly-generated line IDs that the
        /// compiler added during compilation.
        /// </remarks>
        public IDictionary<string, StringInfo> StringTable { get; set; }

        /// <summary>
        /// Gets the collection of variable declarations that were found during
        /// compilation.
        /// </summary>
        /// <remarks>
        /// This value will be <see langword="null"/> if the <see
        /// cref="CompilationJob"/> object's <see
        /// cref="CompilationJob.CompilationType"/> value was not <see
        /// cref="CompilationJob.Type.DeclarationsOnly"/> or <see
        /// cref="CompilationJob.Type.FullCompilation"/>.
        /// </remarks>
        public IEnumerable<Declaration> Declarations { get; set; }

        /// <summary>
        /// Gets a value indicating whether the compiler had to create line IDs
        /// for lines in the source code that lacked <c>#line:</c> tags.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Every line is required to have a line ID. If a line doesn't have a
        /// line ID specified in the source code (via a <c>#line:</c> tag), the
        /// compiler will create one.
        /// </para>
        /// <para>
        /// Implicit line IDs are guaranteed to remain the same between
        /// compilations when the source file does not change. If you want line
        /// IDs to remain the same when the source code may be modified in the
        /// future, add a <c>#line:</c> tag to the line. This may be done by
        /// hand, or added using the <see cref="Utility.AddTagsToLines(string,
        /// ICollection{string})"/> method.
        /// </para>
        /// </remarks>
        public bool ContainsImplicitStringTags { get; set; }

        /// <summary>
        /// Gets the collection of file-level tags found in the source code.
        /// </summary>
        /// <remarks>The keys of this dictionary are the file names (as
        /// indicated by the <see cref="CompilationJob.File.FileName"/> property
        /// of the <see cref="CompilationJob"/>'s <see
        /// cref="CompilationJob.Files"/> collection), and the values are the
        /// file tags associated with that file.
        public Dictionary<string, IEnumerable<string>> FileTags { get; set; }

        /// <summary>
        /// Gets the collection of <see cref="Diagnostic"/> objects that
        /// describe problems in the source code.
        /// </summary>
        /// <remarks>
        /// If the compiler encounters errors while compiling source code, the
        /// <see cref="CompilationResult"/> it produces will have a <see
        /// cref="Program"/> value of <see langword="null"/>. To help figure out
        /// what the error is, users should consult the contents of this
        /// property.
        /// </remarks>
        public IEnumerable<Diagnostic> Diagnostics { get; set; }

        /// <summary>
        /// Gets the collection of <see cref="DebugInfo"/> objects for each node
        /// in <see cref="Program"/>.
        /// </summary>
        public IReadOnlyDictionary<string, DebugInfo> DebugInfo { get; set; }

        /// <summary>
        /// Combines multiple <see cref="CompilationResult"/> objects together
        /// into one object.
        /// </summary>
        /// <param name="results">The compilation result objects to merge
        /// together.</param>
        /// <param name="stringTableManager">A string table builder containing
        /// lines from all of the compilation results in <paramref
        /// name="results"/>.</param>
        /// <returns>The combined compilation result.</returns>
        public static CompilationResult CombineCompilationResults(IEnumerable<CompilationResult> results, StringTableManager stringTableManager)
        {
            List<Program> programs = new List<Program>();
            List<Declaration> declarations = new List<Declaration>();
            Dictionary<string, IEnumerable<string>> tags = new Dictionary<string, IEnumerable<string>>();
            List<Diagnostic> diagnostics = new List<Diagnostic>();
            Dictionary<string, DebugInfo> nodeDebugInfos = new Dictionary<string, DebugInfo>();

            foreach (CompilationResult result in results)
            {
                programs.Add(result.Program);

                if (result.Declarations != null)
                {
                    declarations.AddRange(result.Declarations);
                }

                if (result.FileTags != null)
                {
                    foreach (KeyValuePair<string, IEnumerable<string>> kvp in result.FileTags)
                    {
                        tags.Add(kvp.Key, kvp.Value);
                    }
                }

                if (result.Diagnostics != null)
                {
                    diagnostics.AddRange(result.Diagnostics);
                }

                if (result.DebugInfo != null)
                {
                    foreach (KeyValuePair<string, DebugInfo> kvp in result.DebugInfo)
                    {
                        nodeDebugInfos.Add(kvp.Key, kvp.Value);
                    }
                }
            }

            Program combinedProgram = programs.Count > 0 ? Program.Combine(programs.ToArray()) : null;

            return new CompilationResult
            {
                Program = combinedProgram,
                StringTable = stringTableManager.StringTable,
                Declarations = declarations,
                DebugInfo = nodeDebugInfos,
                ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
                FileTags = tags,
                Diagnostics = diagnostics,
            };
        }
    }

    /// <summary>
    /// Contains debug information for a node in a Yarn file.
    /// </summary>
    public class DebugInfo
    {
        /// <summary>
        /// Gets or sets the file that this DebugInfo was produced from.
        /// </summary>
        public string FileName { get; set; }

        /// <summary>
        /// Gets or sets the node that this DebugInfo was produced from.
        /// </summary>
        public string NodeName { get; set; }

        /// <summary>
        /// Gets or sets the mapping of instruction numbers to line and
        /// character information in the file indicated by <see
        /// cref="FileName"/>.
        /// </summary>
        public Dictionary<int, (int Line, int Character)> LineInfos { get; set; } = new Dictionary<int, (int Line, int Character)>();

        /// <summary>
        /// Gets a <see cref="LineInfo"/> object that describes the specified
        /// instruction at the index <paramref name="instructionNumber"/>.
        /// </summary>
        /// <param name="instructionNumber">The index of the instruction to
        /// retrieve information for.</param>
        /// <returns>A <see cref="LineInfo"/> object that describes the position
        /// of the instruction.</returns>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref
        /// name="instructionNumber"/> is less than zero, or greater than the
        /// number of instructions present in the node.</exception>
        public LineInfo GetLineInfo(int instructionNumber)
        {
            if (this.LineInfos.TryGetValue(instructionNumber, out (int Line, int Character) info))
            {
                return new LineInfo
                {
                    FileName = this.FileName,
                    NodeName = this.NodeName,
                    LineNumber = info.Line,
                    CharacterNumber = info.Character,
                };
            }
            else
            {
                throw new ArgumentOutOfRangeException(nameof(instructionNumber));
            }
        }

        /// <summary>
        /// Contains positional information about an instruction.
        /// </summary>
        public struct LineInfo
        {
            /// <summary>
            /// The file name of the source that this intruction was produced
            /// from.
            /// </summary>
            public string FileName;

            /// <summary>
            /// The node name of the source that this intruction was produced
            /// from.
            /// </summary>
            public string NodeName;

            /// <summary>
            /// The zero-indexed line number in <see cref="FileName"/> that
            /// contains the statement or expression that this line was produced
            /// from.
            /// </summary>
            public int LineNumber;

            /// <summary>
            /// The zero-indexed character number in <see cref="FileName"/> that
            /// contains the statement or expression that this line was produced
            /// from.
            /// </summary>
            public int CharacterNumber;
        }
    }

    /// <summary>
    /// Compiles Yarn code.
    /// </summary>
    public class Compiler : YarnSpinnerParserBaseListener
    {
        /// <summary>A regular expression used to detect illegal characters
        /// in node titles.</summary>
        private readonly Regex invalidNodeTitleNameRegex = new Regex(@"[\[<>\]{}\|:\s#\$]");

        private int labelCount = 0;

        /// <summary>
        /// Gets the current node to which instructions are being added.
        /// </summary>
        /// <value>The current node.</value>
        public Node CurrentNode { get; private set; }

        /// <summary>
        /// Gets the current debug information that describes <see
        /// cref="CurrentNode"/>.
        /// </summary>
        private DebugInfo CurrentDebugInfo { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether we are currently parsing the
        /// current node as a 'raw text' node, or as a fully syntactic node.
        /// </summary>
        /// <value>Whether this is a raw text node or not.</value>
        public bool RawTextNode { get; set; } = false;

        /// <summary>
        /// Gets the program being generated by the compiler.
        /// </summary>
        public Program Program { get; private set; }

        public IList<DebugInfo> DebugInfos { get; private set; } = new List<DebugInfo>();

        public FileParseResult fileParseResult { get; private set; }

        /// <summary>
        /// The list of variable declarations known to the compiler.
        /// </summary>
        /// <remarks>
        /// This is supplied as part of a <see cref="CompilationJob"/>, or by
        /// <see cref="GetDeclarations"/>.
        /// </remarks>
        public IEnumerable<Declaration> VariableDeclarations = new List<Declaration>();

        /// <summary>
        /// The Library, which contains the function declarations known to the
        /// compiler.
        /// </summary>
        /// <remarks>
        /// This is supplied as part of a <see cref="CompilationJob"/>.
        /// </remarks>
        public Library Library { get; private set; }

        /// <summary>
        /// Gets the list of new <see cref="Diagnostic"/> objects created during
        /// code generation.
        /// </summary>
        /// <remarks>
        /// This does not include any existing diagnostics, such as parse
        /// errors.
        /// </remarks>
        public IEnumerable<Diagnostic> Diagnostics { get => this.diagnostics; }

        private List<Diagnostic> diagnostics = new List<Diagnostic>();

        // the list of nodes we have to ensure we track visitation
        private HashSet<string> TrackingNodes;

        /// <summary>
        /// Initializes a new instance of the <see cref="Compiler"/> class.
        /// </summary>
        /// <param name="fileParseResult">The file parse result to use.</param>
        public Compiler(FileParseResult fileParseResult)
        {
            this.Program = new Program();
            this.fileParseResult = fileParseResult;
        }

#if DEBUG
        public string parseTree;
        public List<string> tokens;
#endif

        /// <summary>
        /// Compiles Yarn code, as specified by a compilation job.
        /// </summary>
        /// <param name="compilationJob">The compilation job to perform.</param>
        /// <returns>The results of the compilation.</returns>
        /// <seealso cref="CompilationJob"/>
        /// <seealso cref="CompilationResult"/>
        public static CompilationResult Compile(CompilationJob compilationJob)
        {
            List<CompilationResult> results = new List<CompilationResult>();

            // I think it is bad that we have two variables with identical behaviours and almost identical data
            // we should merge these or at least remove the needed duplication of work

            // All variable declarations that we've encountered during this
            // compilation job
            List<Declaration> derivedVariableDeclarations = new List<Declaration>();

            // All variable declarations that we've encountered, PLUS the
            // ones we knew about before
            List<Declaration> knownVariableDeclarations = new List<Declaration>();

            // All type definitions that we've encountered while parsing.
            List<IType> typeDeclarations = new List<IType>(BuiltinTypes.AllBuiltinTypes);

            if (compilationJob.VariableDeclarations != null)
            {
                knownVariableDeclarations.AddRange(compilationJob.VariableDeclarations);
            }

            List<Diagnostic> diagnostics = new List<Diagnostic>();
            {
                // Get function declarations from the Standard Library
                (IEnumerable<Declaration> declarations, IEnumerable<Diagnostic> declarationDiagnostics) = GetDeclarationsFromLibrary(new Dialogue.StandardLibrary());

                diagnostics.AddRange(declarationDiagnostics);

                knownVariableDeclarations.AddRange(declarations);
            }

            // Get function declarations from the library, if provided
            if (compilationJob.Library != null)
            {
                (IEnumerable<Declaration> declarations, IEnumerable<Diagnostic> declarationDiagnostics) = GetDeclarationsFromLibrary(compilationJob.Library);
                knownVariableDeclarations.AddRange(declarations);
                diagnostics.AddRange(declarationDiagnostics);
            }

            List<FileParseResult> parsedFiles = new List<FileParseResult>();

            // First pass: parse all files, generate their syntax trees,
            // and figure out what variables they've declared
            StringTableManager stringTableManager = new StringTableManager();

            foreach (CompilationJob.File file in compilationJob.Files)
            {
                FileParseResult parseResult = ParseSyntaxTree(file, ref diagnostics);
                parsedFiles.Add(parseResult);

                // ok now we will add in our lastline tags
                // we do this BEFORE we build our strings table otherwise the tags will get missed
                // this should probably be a flag instead of every time though
                LastLineBeforeOptionsVisitor lastLineTagger = new LastLineBeforeOptionsVisitor();
                lastLineTagger.Visit(parseResult.Tree);

                RegisterStrings(file.FileName, stringTableManager, parseResult.Tree, ref diagnostics);
            }

            // Ensure that all nodes names in this compilation are unique. Node
            // name uniqueness is important for several processes, so we do this
            // check here.
            AddErrorsForDuplicateNodeNames(parsedFiles, ref diagnostics);

            if (compilationJob.CompilationType == CompilationJob.Type.StringsOnly)
            {
                // Stop at this point
                return new CompilationResult
                {
                    Declarations = null,
                    ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
                    Program = null,
                    StringTable = stringTableManager.StringTable,
                    Diagnostics = diagnostics,
                };
            }

            // Find the type definitions in these files.
            ParseTreeWalker walker = new ParseTreeWalker();
            foreach (FileParseResult parsedFile in parsedFiles)
            {
                TypeDeclarationListener typeDeclarationVisitor = new TypeDeclarationListener(parsedFile.Name, parsedFile.Tokens, parsedFile.Tree, ref typeDeclarations);

                walker.Walk(typeDeclarationVisitor, parsedFile.Tree);

                diagnostics.AddRange(typeDeclarationVisitor.Diagnostics);
            }

            Dictionary<string, IEnumerable<string>> fileTags = new Dictionary<string, IEnumerable<string>>();

            // Find the variable declarations in these files.
            foreach (FileParseResult parsedFile in parsedFiles)
            {
                GetDeclarations(parsedFile, knownVariableDeclarations, out IEnumerable<Declaration> newDeclarations, typeDeclarations, out IEnumerable<string> newFileTags, out IEnumerable<Diagnostic> declarationDiagnostics);

                knownVariableDeclarations.AddRange(newDeclarations);
                derivedVariableDeclarations.AddRange(newDeclarations);
                diagnostics.AddRange(declarationDiagnostics);

                fileTags.Add(parsedFile.Name, newFileTags);
            }

            List<DeferredTypeDiagnostic> potentialIssues = new List<DeferredTypeDiagnostic>();
            foreach (FileParseResult parsedFile in parsedFiles)
            {
                TypeCheckVisitor checker = new TypeCheckVisitor(parsedFile.Name, knownVariableDeclarations, typeDeclarations);

                checker.Visit(parsedFile.Tree);
                knownVariableDeclarations.AddRange(checker.NewDeclarations);
                derivedVariableDeclarations.AddRange(checker.NewDeclarations);
                diagnostics.AddRange(checker.Diagnostics);

                potentialIssues.AddRange(checker.deferredTypes);

#if VALIDATE_ALL_EXPRESSIONS
                // Validate that the type checker assigned a type to every
                // expression
                var allExpressions = FlattenParseTree(parsedFile.Tree).OfType<YarnSpinnerParser.ExpressionContext>();

                var expressionsWithNoType = allExpressions.Where(e => e.Type == BuiltinTypes.Undefined);

                if (expressionsWithNoType.Count() > 0)
                {
                    string report = string.Join(", ", expressionsWithNoType.Select(e => $"{e.GetTextWithWhitespace()} (line {e.Start.Line})"));

                    throw new InvalidOperationException($"Internal error: The following expressions were not assigned a type: {report}");
                }
#endif
            }

            // determining the nodes we need to track visits on
            // this needs to be done before we finish up with declarations
            // so that any tracking variables are included in the compiled declarations
            HashSet<string> trackingNodes = new HashSet<string>();
            HashSet<string> ignoringNodes = new HashSet<string>();
            foreach (FileParseResult parsedFile in parsedFiles)
            {
                NodeTrackingVisitor thingy = new NodeTrackingVisitor(trackingNodes, ignoringNodes);
                thingy.Visit(parsedFile.Tree);
            }

            // removing all nodes we are told explicitly to not track
            trackingNodes.ExceptWith(ignoringNodes);

            List<Declaration> trackingDeclarations = new List<Declaration>();
            foreach (string node in trackingNodes)
            {
                trackingDeclarations.Add(Declaration.CreateVariable(Library.GenerateUniqueVisitedVariableForNode(node), BuiltinTypes.Number, 0, $"The generated variable for tracking visits of node {node}"));
            }

            // adding the generated tracking variables into the declaration list
            // this way any future variable storage system will know about them
            // if we didn't do this later stages wouldn't be able to interface with them
            knownVariableDeclarations.AddRange(trackingDeclarations);
            derivedVariableDeclarations.AddRange(trackingDeclarations);

            List<Declaration> totalDeclarations = new List<Declaration>();
            totalDeclarations.AddRange(derivedVariableDeclarations);
            totalDeclarations.AddRange(knownVariableDeclarations);

            // ok here we need to run through any deferredTypes we have and see if they got resolved
            foreach (DeferredTypeDiagnostic hmm in potentialIssues)
            {
                bool resolved = false;
                foreach (Declaration dec in totalDeclarations)
                {
                    if (dec.Name == hmm.Name)
                    {
                        resolved = true;
                        break;
                    }
                }
                if (resolved)
                {
                    continue;
                }
                diagnostics.Add(hmm.diagnostic);
            }
            
            FilterDoubledDeclarations(derivedVariableDeclarations, diagnostics, out _);

            if (compilationJob.CompilationType == CompilationJob.Type.DeclarationsOnly)
            {
                // Stop at this point
                return new CompilationResult
                {
                    Declarations = derivedVariableDeclarations,
                    ContainsImplicitStringTags = false,
                    Program = null,
                    StringTable = null,
                    FileTags = fileTags,
                    Diagnostics = diagnostics,
                };
            }


            if (diagnostics.Any(d => d.Severity == Diagnostic.DiagnosticSeverity.Error))
            {
                // We have errors, so we can't safely generate code.
            }
            else
            {
                // No errors! Go ahead and generate the code for all parsed
                // files.
                foreach (FileParseResult parsedFile in parsedFiles)
                {
                    CompilationResult compilationResult = GenerateCode(parsedFile, knownVariableDeclarations, compilationJob, stringTableManager, trackingNodes);

                    results.Add(compilationResult);
                }
            }

            CompilationResult finalResult = CompilationResult.CombineCompilationResults(results, stringTableManager);

            // Last step: take every variable declaration we found in all
            // of the inputs, and create an initial value registration for
            // it.
            if (finalResult.Program != null)
            {
                FilterDoubledDeclarations(knownVariableDeclarations, diagnostics, out List<(Declaration, Operand)> resolvedInitials);
                foreach ((Declaration declaration, Operand value) in resolvedInitials)
                    finalResult.Program.InitialValues[declaration.Name] = value;
            }

            finalResult.Declarations = derivedVariableDeclarations;

            finalResult.FileTags = fileTags;

            finalResult.Diagnostics = finalResult.Diagnostics.Concat(diagnostics).Distinct();

            return finalResult;
        }

        private static void FilterDoubledDeclarations(List<Declaration> declarations, List<Diagnostic> diagnostics, out List<(Declaration, Operand)> resolvedValues)
        {
            Declaration[] variableDeclarations = declarations.Where(d =>
                {
                    switch (d.Type)
                    {
                        case FunctionType _:
                        case BuiltinTypes.Undefined:
                            return false;
                    }

                    if (d.DefaultValue == null)
                    {
                        diagnostics.Add(new Diagnostic($"Variable declaration {d.Name} (type {d.Type?.Name ?? "undefined"}) has a null default value. This is not allowed."));
                        return false;
                    }

                    return true;
                }).ToArray();

            resolvedValues = new List<(Declaration, Operand)>();
            HashSet<string> unresolvedDeclarations = new(variableDeclarations.Select(d => d.Name));
            List<(string, Diagnostic)> deferredDiagnostics = new();

            foreach (Declaration declaration in variableDeclarations)
            {
                Operand value;
                switch (declaration.Type)
                {
                    case var t when t == BuiltinTypes.String:
                        value = new Operand(Convert.ToString(declaration.DefaultValue));
                        break;
                    case var t when t == BuiltinTypes.Number:
                        value = new Operand(Convert.ToSingle(declaration.DefaultValue));
                        break;
                    case var t when t == BuiltinTypes.Boolean:
                        value = new Operand(Convert.ToBoolean(declaration.DefaultValue));
                        break;
                    default:
                        deferredDiagnostics.Add((declaration.Name, new Diagnostic($"Cannot create an initial value for type {declaration.Type.Name}, default value: {declaration.DefaultValue}", Diagnostic.DiagnosticSeverity.Error)));
                        continue;
                }

                unresolvedDeclarations.Remove(declaration.Name);
                resolvedValues.Add((declaration, value));
            }

            for (int index = 0; index < deferredDiagnostics.Count; index++)
            {
                (string name, Diagnostic diagnostic) element = deferredDiagnostics[index];
                if (unresolvedDeclarations.Contains(element.name))
                {
                    deferredDiagnostics.RemoveAt(index);
                    index--;
                }
            }
            
            foreach ((_, Diagnostic diagnostic) in deferredDiagnostics)
                diagnostics.Add(diagnostic);

            for (int i = 0; i < resolvedValues.Count; i++)
            {
                (Declaration declaration, Operand value) outer = resolvedValues[i];
                for (int j = i + 1; j < resolvedValues.Count; j++)
                {
                    (Declaration declaration, Operand value) inner = resolvedValues[j];
                    if (outer.declaration.Name != inner.declaration.Name)
                        continue;

                    IType outerType = outer.declaration.Type;
                    IType innerType = inner.declaration.Type;
                    if (outerType != innerType)
                    {
                        diagnostics.Add(new Diagnostic($"Variable {outer.declaration.Name} has multiple declarations with different types: {outerType.Name} and {innerType.Name}",
                                                       Diagnostic.DiagnosticSeverity.Warning));
                    }

                    if (outerType == BuiltinTypes.Boolean)
                    {
                        resolvedValues.RemoveAt(j);
                        j--;
                    }
                    else if (innerType == BuiltinTypes.Boolean)
                    {
                        resolvedValues.RemoveAt(i);
                        i--;
                        break;
                    }
                    else if (outerType == BuiltinTypes.Number)
                    {
                        resolvedValues.RemoveAt(j);
                        j--;
                    }
                    else if (innerType == BuiltinTypes.Number)
                    {
                        resolvedValues.RemoveAt(i);
                        i--;
                        break;
                    }
                    else
                    {
                        resolvedValues.RemoveAt(j);
                        j--;
                    }
                }
            }
            
            declarations.Clear();
            declarations.AddRange(resolvedValues.Select(d => d.Item1));
        }

        /// <summary>
        /// Checks every node name in <paramref name="parseResults"/>, and
        /// ensure that they're all unique. If there are duplicates, create
        /// diagnostics where any node overlaps.
        /// </summary>
        /// <param name="parseResults">A collection of file parse results to
        /// check.</param>
        /// <param name="diagnostics">A collection of diagnostics to add
        /// to.</param>
        private static void AddErrorsForDuplicateNodeNames(List<FileParseResult> parseResults, ref List<Diagnostic> diagnostics)
        {
            IEnumerable<(YarnSpinnerParser.NodeContext Node, FileParseResult File)> allNodes = parseResults.SelectMany(r =>
            {
                YarnSpinnerParser.DialogueContext dialogue = r.Tree.Payload as YarnSpinnerParser.DialogueContext;
                if (dialogue == null)
                {
                    return Enumerable.Empty<(YarnSpinnerParser.NodeContext Node, FileParseResult File)>();
                }

                return dialogue.node().Select(n => (Node: n, File: r));
            });

            // Pair up every node with its name, and filter out any that don't
            // have a name
            IEnumerable<(string Name, YarnSpinnerParser.HeaderContext Header, YarnSpinnerParser.NodeContext Node, FileParseResult File)> nodesWithNames = allNodes.Select(n =>
            {
                YarnSpinnerParser.HeaderContext titleHeader = GetHeadersWithKey(n.Node, "title").FirstOrDefault();
                if (titleHeader == null)
                {
                    return (
                               Name: null,
                               Header: null,
                               Node: n.Node,
                               File: n.File);
                }
                else
                {
                    return (
                               Name: titleHeader.header_value.Text, 
                               Header: titleHeader,
                               Node: n.Node,
                               File: n.File);
                }
            }).Where(kv => kv.Name != null);

            IEnumerable<IGrouping<string, (string Name, YarnSpinnerParser.HeaderContext Header, YarnSpinnerParser.NodeContext Node, FileParseResult File)>> nodesByName = nodesWithNames.GroupBy(n => n.Name);

            // Find groups of nodes with the same name and generate diagnostics
            // for each
            foreach (IGrouping<string, (string Name, YarnSpinnerParser.HeaderContext Header, YarnSpinnerParser.NodeContext Node, FileParseResult File)> group in nodesByName)
            {
                if (group.Count() == 1)
                {
                    continue;
                }

                // More than one node has this name! Report an error on both.
                foreach ((string Name, YarnSpinnerParser.HeaderContext Header, YarnSpinnerParser.NodeContext Node, FileParseResult File) entry in group)
                {
                    Diagnostic d = new Diagnostic(entry.File.Name, entry.Header, $"More than one node is named {entry.Name}");
                    diagnostics.Add(d);
                }
            }
        }

        private static void RegisterStrings(string fileName, StringTableManager stringTableManager, IParseTree tree, ref List<Diagnostic> diagnostics)
        {
            StringTableGeneratorVisitor visitor = new StringTableGeneratorVisitor(fileName, stringTableManager);
            visitor.Visit(tree);
            diagnostics.AddRange(visitor.Diagnostics);
        }

        private static void GetDeclarations(FileParseResult parsedFile, IEnumerable<Declaration> existingDeclarations, out IEnumerable<Declaration> newDeclarations, IEnumerable<IType> typeDeclarations, out IEnumerable<string> fileTags, out IEnumerable<Diagnostic> diagnostics)
        {
            DeclarationVisitor variableDeclarationVisitor = new DeclarationVisitor(parsedFile.Name, existingDeclarations, typeDeclarations, parsedFile.Tokens);

            List<Diagnostic> newDiagnosticList = new List<Diagnostic>();

            variableDeclarationVisitor.Visit(parsedFile.Tree);

            newDiagnosticList.AddRange(variableDeclarationVisitor.Diagnostics);

            // Upon exit, newDeclarations will now contain every variable
            // declaration we found
            newDeclarations = variableDeclarationVisitor.NewDeclarations;

            fileTags = variableDeclarationVisitor.FileTags;

            diagnostics = newDiagnosticList;
        }

        private static CompilationResult GenerateCode(FileParseResult fileParseResult, IEnumerable<Declaration> variableDeclarations, CompilationJob job, StringTableManager stringTableManager, HashSet<string> trackingNodes)
        {
            Compiler compiler = new Compiler(fileParseResult);

            compiler.TrackingNodes = trackingNodes;
            compiler.Library = job.Library;
            compiler.VariableDeclarations = variableDeclarations;
            compiler.Compile();

            Dictionary<string, DebugInfo> debugInfoDictionary = new Dictionary<string, DebugInfo>();

            // Don't attempt to generate debug information if compilation
            // produced errors
            if (!compiler.Diagnostics.Any(d => d.Severity == Diagnostic.DiagnosticSeverity.Error))
            {
                foreach (DebugInfo debugInfo in compiler.DebugInfos)
                {
                    debugInfoDictionary.Add(debugInfo.NodeName, debugInfo);
                }
            }

            return new CompilationResult
            {
                Program = compiler.Program,
                DebugInfo = debugInfoDictionary,
                StringTable = stringTableManager.StringTable,
                ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
                Diagnostics = compiler.Diagnostics,
            };
        }

        /// <summary>
        /// Returns a collection of <see cref="Declaration"/> structs that
        /// describe the functions present in <paramref name="library"/>.
        /// </summary>
        /// <param name="library">The <see cref="Library"/> to get declarations
        /// from.</param>
        /// <returns>The <see cref="Declaration"/> structs found.</returns>
        public static (IEnumerable<Declaration>, IEnumerable<Diagnostic>) GetDeclarationsFromLibrary(Library library)
        {
            List<Declaration> declarations = new List<Declaration>();

            List<Diagnostic> diagnostics = new List<Diagnostic>();

            foreach (KeyValuePair<string, Delegate> function in library.Delegates)
            {
                MethodInfo method = function.Value.Method;

                if (method.ReturnType == typeof(Value))
                {
                    // Functions that return the public type Values are
                    // operators, and are type checked by
                    // ExpressionTypeVisitor. (Future work: define each
                    // polymorph of each operator as a separate function
                    // that returns a concrete type, rather than the
                    // current method of having a 'Value' wrapper type).
                    continue;
                }

                // Does the return type of this delegate map to a value
                // that Yarn Spinner can use?
                if (BuiltinTypes.TypeMappings.TryGetValue(method.ReturnType, out IType yarnReturnType) == false)
                {
                    diagnostics.Add(new Diagnostic($"Function {function.Key} cannot be used in Yarn Spinner scripts: {method.ReturnType} is not a valid return type."));
                    continue;
                }

                // Define a new type for this function
                FunctionType functionType = new FunctionType();

                bool includeMethod = true;

                foreach (ParameterInfo paramInfo in method.GetParameters())
                {
                    if (paramInfo.ParameterType == typeof(Value))
                    {
                        // Don't type-check this method - it's an operator
                        includeMethod = false;
                        break;
                    }

                    if (paramInfo.IsOptional)
                    {
                        diagnostics.Add(new Diagnostic($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name} is optional, which isn't supported."));
                        continue;
                    }

                    if (paramInfo.IsOut)
                    {
                        diagnostics.Add(new Diagnostic($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name} is an out parameter, which isn't supported."));
                        continue;
                    }

                    if (BuiltinTypes.TypeMappings.TryGetValue(paramInfo.ParameterType, out IType yarnParameterType) == false)
                    {
                        diagnostics.Add(new Diagnostic($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name}'s type ({paramInfo.ParameterType}) cannot be used in Yarn functions"));
                        continue;
                    }

                    functionType.AddParameter(yarnParameterType);
                }

                if (includeMethod == false)
                {
                    continue;
                }

                functionType.ReturnType = yarnReturnType;

                Declaration declaration = new Declaration
                                          {
                                              Name = function.Key,
                                              Type = functionType,
                                              Range = { },
                                              SourceFileName = Declaration.ExternalDeclaration,
                                              SourceNodeName = null,
                                          };

                declarations.Add(declaration);
            }

            return (declarations, diagnostics);
        }

        private static FileParseResult ParseSyntaxTree(CompilationJob.File file, ref List<Diagnostic> diagnostics)
        {
            string source = file.Source;
            string fileName = file.FileName;

            return ParseSyntaxTree(fileName, source, ref diagnostics);
        }

        public static FileParseResult ParseSyntaxTree(string fileName, string source, ref List<Diagnostic> diagnostics)
        {
            ICharStream input = CharStreams.fromstring(source);

            YarnSpinnerLexer lexer = new YarnSpinnerLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);

            YarnSpinnerParser parser = new YarnSpinnerParser(tokens);

            // turning off the normal error listener and using ours
            ParserErrorListener parserErrorListener = new ParserErrorListener(fileName);
            LexerErrorListener lexerErrorListener = new LexerErrorListener(fileName);

            parser.ErrorHandler = new ErrorStrategy();

            parser.RemoveErrorListeners();
            parser.AddErrorListener(parserErrorListener);

            lexer.RemoveErrorListeners();
            lexer.AddErrorListener(lexerErrorListener);

            IParseTree tree;

            tree = parser.dialogue();

            IEnumerable<Diagnostic> newDiagnostics = lexerErrorListener.Diagnostics.Concat(parserErrorListener.Diagnostics);

            diagnostics.AddRange(newDiagnostics);

            return new FileParseResult(fileName, tree, tokens);
        }

        /// <summary>
        /// Reads the contents of a text file containing source code, and
        /// returns a list of tokens found in that source code.
        /// </summary>
        /// <param name="path">The path of the file to load the source code
        /// from.</param>
        /// <inheritdoc cref="GetTokensFromString(string)" path="/returns"/>
        public static List<string> GetTokensFromFile(string path)
        {
            string text = File.ReadAllText(path);
            return GetTokensFromString(text);
        }

        /// <summary>
        /// Reads a string containing source code, and returns a list of
        /// tokens found in that source code.
        /// </summary>
        /// <param name="text">The source code to extract tokens
        /// from.</param>
        /// <returns>The list of tokens extracted from the source
        /// code.</returns>
        public static List<string> GetTokensFromString(string text)
        {
            ICharStream input = CharStreams.fromstring(text);

            YarnSpinnerLexer lexer = new YarnSpinnerLexer(input);

            List<string> tokenStringList = new List<string>();

            IList<IToken> tokens = lexer.GetAllTokens();
            foreach (IToken token in tokens)
            {
                tokenStringList.Add($"{token.Line}:{token.Column} {YarnSpinnerLexer.DefaultVocabulary.GetDisplayName(token.Type)} \"{token.Text}\"");
            }

            return tokenStringList;
        }

        /// <summary>
        /// Finds all header parse contexts in the given node with the given key.
        /// </summary>
        /// <param name="nodeContext">The node context to search.</param>
        /// <param name="name">The key to search for</param>
        /// <returns>A collection of header contexts.</returns>
        public static IEnumerable<YarnSpinnerParser.HeaderContext> GetHeadersWithKey(YarnSpinnerParser.NodeContext nodeContext, string name)
        {
            return nodeContext.header().Where(h => h.header_key?.Text == name);
        }

        /// <summary>
        /// Generates a unique label name to use in the program.
        /// </summary>
        /// <param name="commentary">Any additional text to append to the
        /// end of the label.</param>
        /// <returns>The new label name.</returns>
        public string RegisterLabel(string commentary = null)
        {
            return "L" + this.labelCount++ + commentary;
        }

        /// <summary>
        /// Creates a new instruction, and appends it to a node in the <see
        /// cref="Program" />.
        /// </summary>
        /// <param name="node">The node to append instructions to.</param>
        /// <param name="debugInfo">The <see cref="DebugInfo"/> object to add
        /// line debugging information to.</param>
        /// <param name="sourceLine">The zero-indexed line in the source input
        /// corresponding to this instruction.</param>
        /// <param name="sourceCharacter">The zero-indexed character in the
        /// source input corresponding to this instruction.</param>
        /// <param name="code">The opcode of the instruction.</param>
        /// <param name="operands">The operands to associate with the
        /// instruction.</param>
        void Emit(Node node, DebugInfo debugInfo, int sourceLine, int sourceCharacter, OpCode code, params Operand[] operands)
        {
            Instruction instruction = new Instruction
                                      {
                                          Opcode = code,
                                      };

            instruction.Operands.Add(operands);

            debugInfo.LineInfos.Add(node.Instructions.Count, (sourceLine, sourceCharacter));

            node.Instructions.Add(instruction);
        }

        /// <summary>
        /// Creates a new instruction, and appends it to the current node in the
        /// <see cref="Program"/>.
        /// </summary>
        /// <remarks>
        /// Called by instances of <see
        /// cref="CodeGenerationVisitor"/> while walking the parse tree.
        /// </remarks>
        /// <param name="code">The opcode of the instruction.</param>
        /// <param name="startToken">The first token in the expression or
        /// statement that was responsible for emitting this
        /// instruction.</param>
        /// <param name="operands">The operands to associate with the
        /// instruction.</param>
        public void Emit(OpCode code, IToken startToken, params Operand[] operands)
        {
            this.Emit(this.CurrentNode, this.CurrentDebugInfo, startToken?.Line - 1 ?? -1, startToken?.Column ?? -1, code, operands);
        }

        /// <summary>
        /// Creates a new instruction, and appends it to the current node in the
        /// <see cref="Program"/>.
        /// Differs from the other Emit call by not requiring a start token.
        /// This enables its use in pure synthesised elements of the Yarn.
        /// </summary>
        /// <remarks>
        /// Called by instances of <see
        /// cref="CodeGenerationVisitor"/> while walking the parse tree.
        /// </remarks>
        /// <param name="code">The opcode of the instruction.</param>
        /// <param name="operands">The operands to associate with the
        /// instruction.</param>
        public void Emit(OpCode code, params Operand[] operands)
        {
            this.Emit(this.CurrentNode, this.CurrentDebugInfo, -1, -1, code, operands);
        }

        /// <summary>
        /// Extracts a line ID from a collection of <see
        /// cref="YarnSpinnerParser.HashtagContext"/>s, if one exists.
        /// </summary>
        /// <param name="hashtagContexts">The hashtag parsing
        /// contexts.</param>
        /// <returns>The line ID if one is present in the hashtag contexts,
        /// otherwise <c>null</c>.</returns>
        public static YarnSpinnerParser.HashtagContext GetLineIDTag(YarnSpinnerParser.HashtagContext[] hashtagContexts)
        {
            // if there are any hashtags
            if (hashtagContexts != null)
            {
                foreach (YarnSpinnerParser.HashtagContext hashtagContext in hashtagContexts)
                {
                    string tagText = hashtagContext.text.Text;
                    if (tagText.StartsWith("line:", StringComparison.InvariantCulture))
                    {
                        return hashtagContext;
                    }
                }
            }

            return null;
        }

        // this replaces the CompileNode from the old compiler will start
        // walking the parse tree emitting byte code as it goes along this
        // will all get stored into our program var needs a tree to walk,
        // this comes from the ANTLR Parser/Lexer steps
        public void Compile()
        {
            ParseTreeWalker walker = new ParseTreeWalker();
            walker.Walk(this, this.fileParseResult.Tree);
        }

        // we have found a new node set up the currentNode var ready to
        // hold it and otherwise continue
        public override void EnterNode(YarnSpinnerParser.NodeContext context)
        {
            this.CurrentNode = new Node();
            this.CurrentDebugInfo = new DebugInfo();
            this.RawTextNode = false;
        }

        // have left the current node store it into the program wipe the
        // var and make it ready to go again
        public override void ExitNode(YarnSpinnerParser.NodeContext context)
        {
            if (string.IsNullOrEmpty(this.CurrentNode.Name)) {
                // We don't have a name for this node. We can't emit code for
                // it.
                this.diagnostics.Add(new Diagnostic(
                    this.fileParseResult.Name,
                    context,
                    "Missing title header for node"));
            }
            else
            {
                if (!this.Program.Nodes.ContainsKey(this.CurrentNode.Name))
                {
                    this.Program.Nodes[this.CurrentNode.Name] = this.CurrentNode;
                }
                else
                {
                    // Duplicate node name! We'll have caught this during the
                    // declarations pass, so no need to issue an error here.
                }

                this.CurrentDebugInfo.NodeName = this.CurrentNode.Name;
                this.CurrentDebugInfo.FileName = this.fileParseResult.Name;

                this.DebugInfos.Add(this.CurrentDebugInfo);
            }

            this.CurrentNode = null;
            this.RawTextNode = false;
        }

        // have finished with the header so about to enter the node body
        // and all its statements do the initial setup required before
        // compiling that body statements eg emit a new startlabel
        public override void ExitHeader(YarnSpinnerParser.HeaderContext context)
        {
            string headerKey = context.header_key.Text;

            // Use the header value if provided, else fall back to the
            // empty string. This means that a header like "foo: \n" will
            // be stored as 'foo', '', consistent with how it was typed.
            // That is, it's not null, because a header was provided, but
            // it was written as an empty line.
            string headerValue = context.header_value?.Text ?? "";

            if (headerKey.Equals("title", StringComparison.InvariantCulture))
            {
                // Set the name of the node
                this.CurrentNode.Name = headerValue;

                // Throw an exception if this node name contains illegal
                // characters
                if (this.invalidNodeTitleNameRegex.IsMatch(this.CurrentNode.Name))
                {
                    this.diagnostics.Add(new Diagnostic(this.fileParseResult.Name, context, $"The node '{this.CurrentNode.Name}' contains illegal characters in its title."));
                }
            }

            if (headerKey.Equals("tags", StringComparison.InvariantCulture))
            {
                // Split the list of tags by spaces, and use that
                string[] tags = headerValue.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                this.CurrentNode.Tags.Add(tags);

                if (this.CurrentNode.Tags.Contains("rawText"))
                {
                    // This is a raw text node. Flag it as such for future
                    // compilation.
                    this.RawTextNode = true;
                }
            }
        }

        // have entered the body the header should have finished being
        // parsed and currentNode ready all we do is set up a body visitor
        // and tell it to run through all the statements it handles
        // everything from that point onwards
        public override void EnterBody(YarnSpinnerParser.BodyContext context)
        {
            // ok so something in here needs to be a bit different
            // also need to emit tracking code here for when we fall out of a node that needs tracking?
            // or should do I do in inside the codegenvisitor?

            // if it is a regular node
            if (!this.RawTextNode)
            {
                // This is the start of a node that we can jump to. Add a
                // label at this point.
                this.CurrentNode.Labels.Add(this.RegisterLabel(), this.CurrentNode.Instructions.Count);

                string track = TrackingNodes.Contains(CurrentNode.Name) ? Library.GenerateUniqueVisitedVariableForNode(CurrentNode.Name) : null;

                CodeGenerationVisitor visitor = new CodeGenerationVisitor(this, track);

                foreach (YarnSpinnerParser.StatementContext statement in context.statement())
                {
                    visitor.Visit(statement);
                }
            }
            // We are a rawText node. Don't compile it; instead, note the
            // string
            else
            {
                this.CurrentNode.SourceTextStringID = GetLineIDForNodeName(this.CurrentNode.Name);
            }
        }

        public static string GetLineIDForNodeName(string name)
        {
            return "line:" + name;
        }

        public override void ExitBody(YarnSpinnerParser.BodyContext context)
        {
            // this gives us the final increment at the end of the node
            // this is for when we visit and complete a node without a jump
            // theoretically this does mean that there might be redundant increments
            // but I don't think it will matter because a jump always prevents
            // the extra increment being reached
            // a bit inelegant to do it this way but the codegen visitor doesn't exit a node
            // will do for now, shouldn't be hard to refactor this later
            string track = TrackingNodes.Contains(CurrentNode.Name) ? Library.GenerateUniqueVisitedVariableForNode(CurrentNode.Name) : null;
            if (track != null)
            {
                CodeGenerationVisitor.GenerateTrackingCode(this, track);
            }
            // We have exited the body; emit a 'stop' opcode here.
            this.Emit(this.CurrentNode, this.CurrentDebugInfo, context.Stop.Line - 1, 0, OpCode.Stop);
        }

        /// <summary>
        /// Flattens a tree of <see cref="IParseTree"/> objects by
        /// recursively visiting their children, and converting them into a
        /// flat <see cref="IEnumerable{IParseTree}"/>.
        /// </summary>
        /// <param name="node">The root node to begin work from.</param>
        /// <returns>An <see cref="IEnumerable{T}"/> that contains a
        /// flattened version of the hierarchy rooted at <paramref
        /// name="node"/>.</returns>
        public static IEnumerable<IParseTree> FlattenParseTree(IParseTree node)
        {
            // Get the list of children in this node
            IEnumerable<IParseTree> children = Enumerable
                                               .Range(0, node.ChildCount)
                                               .Select(i => node.GetChild(i));

            // Recursively visit each child and append it to a sequence,
            // and then return that sequence
            return children
                .SelectMany(c => FlattenParseTree(c))
                .Concat(new[] { node });
        }

        /// <summary>
        /// Gets the text of the documentation comments that either immediately
        /// precede <paramref name="context"/>, or are on the same line as
        /// <paramref name="context"/>.
        /// </summary>
        /// <remarks>
        /// Documentation comments begin with a triple-slash (<c>///</c>), and
        /// are used to describe variable declarations. If documentation
        /// comments precede a declaration (that is, they're not on the same
        /// line as the declaration), then they may span multiple lines, as long
        /// as each line begins with a triple-slash.
        /// </remarks>
        /// <param name="tokens">The token stream to search.</param>
        /// <param name="context">The parser rule context to get documentation
        /// comments for.</param>
        /// <param name="allowCommentsAfter">If true, this method will search
        /// for documentation comments that come after <paramref
        /// name="context"/>'s last token and are on the same line.</param>
        /// <returns>The text of the documentation comments.</returns>
        public static string GetDocumentComments(CommonTokenStream tokens, ParserRuleContext context, bool allowCommentsAfter = true)
        {
            string description = null;

            IList<IToken> precedingComments = tokens.GetHiddenTokensToLeft(context.Start.TokenIndex, YarnSpinnerLexer.COMMENTS);

            if (precedingComments != null)
            {
                IEnumerable<string> precedingDocComments = precedingComments
                                                           // There are no tokens on the main channel with this
                                                           // one on the same line
                                                           .Where(t => tokens.GetTokens()
                                                                             .Where(ot => ot.Line == t.Line)
                                                                             .Where(ot => ot.Type != YarnSpinnerLexer.INDENT && ot.Type != YarnSpinnerLexer.DEDENT)
                                                                             .Where(ot => ot.Channel == Lexer.DefaultTokenChannel)
                                                                             .Count() == 0)
                                                           // The comment starts with a triple-slash
                                                           .Where(t => t.Text.StartsWith("///"))
                                                           // Get its text
                                                           .Select(t => t.Text.Replace("///", string.Empty).Trim());

                if (precedingDocComments.Count() > 0)
                {
                    description = string.Join(" ", precedingDocComments);
                }
            }

            if (allowCommentsAfter)
            {
                IList<IToken> subsequentComments = tokens.GetHiddenTokensToRight(context.Stop.TokenIndex, YarnSpinnerLexer.COMMENTS);
                if (subsequentComments != null)
                {
                    string subsequentDocComment = subsequentComments
                                                  // This comment is on the same line as the end of
                                                  // the declaration
                                                  .Where(t => t.Line == context.Stop.Line)
                                                  // The comment starts with a triple-slash
                                                  .Where(t => t.Text.StartsWith("///"))
                                                  // Get its text
                                                  .Select(t => t.Text.Replace("///", string.Empty).Trim())
                                                  // Get the first one, or null
                                                  .FirstOrDefault();

                    if (subsequentDocComment != null)
                    {
                        description = subsequentDocComment;
                    }
                }
            }

            return description;
        }
    }

    /// <summary>
    /// Contains the result of parsing a single file of source code.
    /// </summary>
    /// <remarks>
    /// This class provides only syntactic information about a parse - that is,
    /// it provides access to the parse tree, and the stream of tokens used to
    /// produce that parse tree.
    /// </remarks>
    public struct FileParseResult
    {
        /// <summary>
        /// <inheritdoc cref="FileParseResult(string, IParseTree, CommonTokenStream)" path="/param[@name='name']"/>
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// <inheritdoc cref="FileParseResult(string, IParseTree, CommonTokenStream)" path="/param[@name='tree']"/>
        /// </summary>
        public IParseTree Tree { get; }

        /// <summary>
        /// <inheritdoc cref="FileParseResult(string, IParseTree, CommonTokenStream)" path="/param[@name='tokens']"/>
        /// </summary>
        public CommonTokenStream Tokens { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="FileParseResult"/>
        /// struct.
        /// </summary>
        /// <param name="name">The name of the file.</param>
        /// <param name="tree">The parse tree extracted from the file.</param>
        /// <param name="tokens">The tokens extracted from the file.</param>
        public FileParseResult(string name, IParseTree tree, CommonTokenStream tokens)
        {
            this.Name = name;
            this.Tree = tree;
            this.Tokens = tokens;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            return obj is FileParseResult other &&
                   this.Name == other.Name &&
                   EqualityComparer<IParseTree>.Default.Equals(this.Tree, other.Tree) &&
                   EqualityComparer<CommonTokenStream>.Default.Equals(this.Tokens, other.Tokens);
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int hashCode = -1713343069;
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(this.Name);
            hashCode = hashCode * -1521134295 + EqualityComparer<IParseTree>.Default.GetHashCode(this.Tree);
            hashCode = hashCode * -1521134295 + EqualityComparer<CommonTokenStream>.Default.GetHashCode(this.Tokens);
            return hashCode;
        }
    }
}
